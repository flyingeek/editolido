(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["editolido"] = factory();
	else
		root["editolido"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: GeoPoint, KMLGenerator, Route, Track, rad_to_nm, nm_to_rad, PIN_BROWN, PIN_BLUE, PIN_PINK, PIN_PURPLE, PIN_YELLOW, PIN_RED, PIN_ORANGE, PIN_GREEN, PIN_NONE, NAT_POSITION_ENTRY, NAT_POSITION_EXIT, template, styleTemplate, iconTemplate, avenzaTemplate, avenzaStyleTemplate, avenzaIconTemplate, PINS, GOOGLEICONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_geopoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/geopoint */ \"./src/modules/geopoint.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GeoPoint\", function() { return _modules_geopoint__WEBPACK_IMPORTED_MODULE_0__[\"GeoPoint\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rad_to_nm\", function() { return _modules_geopoint__WEBPACK_IMPORTED_MODULE_0__[\"rad_to_nm\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"nm_to_rad\", function() { return _modules_geopoint__WEBPACK_IMPORTED_MODULE_0__[\"nm_to_rad\"]; });\n\n/* harmony import */ var _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/kml_constants */ \"./src/modules/kml_constants.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_BROWN\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_BROWN\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_BLUE\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_BLUE\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_PINK\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_PINK\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_PURPLE\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_PURPLE\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_YELLOW\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_YELLOW\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_RED\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_RED\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_ORANGE\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_ORANGE\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_GREEN\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_GREEN\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIN_NONE\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PIN_NONE\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NAT_POSITION_ENTRY\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"NAT_POSITION_ENTRY\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NAT_POSITION_EXIT\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"NAT_POSITION_EXIT\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PINS\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"PINS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GOOGLEICONS\", function() { return _modules_kml_constants__WEBPACK_IMPORTED_MODULE_1__[\"GOOGLEICONS\"]; });\n\n/* harmony import */ var _modules_route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/route */ \"./src/modules/route.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Route\", function() { return _modules_route__WEBPACK_IMPORTED_MODULE_2__[\"Route\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Track\", function() { return _modules_route__WEBPACK_IMPORTED_MODULE_2__[\"Track\"]; });\n\n/* harmony import */ var _modules_kml_templates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/kml_templates */ \"./src/modules/kml_templates.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"template\", function() { return _modules_kml_templates__WEBPACK_IMPORTED_MODULE_3__[\"template\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"styleTemplate\", function() { return _modules_kml_templates__WEBPACK_IMPORTED_MODULE_3__[\"styleTemplate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"iconTemplate\", function() { return _modules_kml_templates__WEBPACK_IMPORTED_MODULE_3__[\"iconTemplate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"avenzaTemplate\", function() { return _modules_kml_templates__WEBPACK_IMPORTED_MODULE_3__[\"avenzaTemplate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"avenzaStyleTemplate\", function() { return _modules_kml_templates__WEBPACK_IMPORTED_MODULE_3__[\"avenzaStyleTemplate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"avenzaIconTemplate\", function() { return _modules_kml_templates__WEBPACK_IMPORTED_MODULE_3__[\"avenzaIconTemplate\"]; });\n\n/* harmony import */ var _modules_kml__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/kml */ \"./src/modules/kml.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"KMLGenerator\", function() { return _modules_kml__WEBPACK_IMPORTED_MODULE_4__[\"KMLGenerator\"]; });\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://editolido/./src/index.js?");

/***/ }),

/***/ "./src/modules/geolite.js":
/*!********************************!*\
  !*** ./src/modules/geolite.js ***!
  \********************************/
/*! exports provided: LatLng, LatPhi, latphi2latlng, latlng2dm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatLng\", function() { return LatLng; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatPhi\", function() { return LatPhi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"latphi2latlng\", function() { return latphi2latlng; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"latlng2dm\", function() { return latlng2dm; });\n/*\nlatitude is the latitude in degrees\nlongitude is the longitude in degrees\n\nrlat is the latitude in radians (lambda is a reserved name in python)\nphi is the longitude in radians\n\nLatLng is the base object when using degrees\nLatPhi is the base object when using lradians\n*/\n\n/**\n * LatLng\n *\n * @property {number} latitude - latitude in degrees\n * @property {number} longitude - longitude in degrees\n * @property {LatPhi} asLatPhi - convert to a LatPhi\n */\nclass LatLng {\n    constructor(latitude, longitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatLng';\n    }\n\n    /**\n     *Degrees Minutes representation of LatLng\n     * exemple: N09W020.3\n     * @returns {String}\n     */\n    get asDM() {\n        const format = function (v, letters = \"NS\") {\n            let value = Math.abs(v);\n            let degrees = Math.floor(value);\n            let rest = (value - degrees) * 60;\n            let minutes = Math.floor(rest);\n            let cents = Math.round((rest - minutes) * 10);\n            if (cents >= 10) {\n                cents = 0;\n                minutes += 1;\n            }\n            if (minutes >= 60) {\n                minutes = 0;\n                degrees += 1;\n            }\n            let letter = \"\",\n                padding = 2;\n            if (letters === 'NS') {\n                letter = (v >= 0) ? letters[0] : letters[1];\n            } else {\n                letter = (v > 0) ? letters[0] : letters[1];\n                padding = 3;\n            }\n            return [\n                letter,\n                degrees.toFixed(0).padStart(padding, \"0\"),\n                minutes.toFixed(0).padStart(2, \"0\"),\n                '.' + cents.toFixed(0)\n            ].join('');\n        }\n        return format(this.latitude) + format(this.longitude, 'EW');\n    }\n\n    get asLatPhi() {\n        const [rlat, phi] = [this.latitude, this.longitude].map((d) => d * Math.PI / 180);\n        return new LatPhi(rlat, phi);\n    }\n}\n\n/**\n * LatPhi\n *\n * @property {number} rlat - latitude in radians\n * @property {number} phi - longitude in radians\n * @property {LatLng} asLatLng - convert to a LatLng\n */\nclass LatPhi {\n    constructor(rlat, phi) {\n        this.rlat = rlat;\n        this.phi = phi;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatPhi';\n    }\n\n    /**\n     * asLatLng return a new corresponding LatLng object\n     * @returns {LatLng}\n     */\n    get asLatLng() {\n        const [latitude, longitude] = [this.rlat, this.phi].map((r) => r * 180 / Math.PI);\n        return new LatLng(latitude, longitude);\n    }\n}\n\n//helper for python like code\nconst latphi2latlng = (latphi) => latphi.asLatLng;\nconst latlng2dm = (latlng) => latlng.asDM;\n\n\n\n\n//# sourceURL=webpack://editolido/./src/modules/geolite.js?");

/***/ }),

/***/ "./src/modules/geopoint.js":
/*!*********************************!*\
  !*** ./src/modules/geopoint.js ***!
  \*********************************/
/*! exports provided: array_normalizer, dm_normalizer, arinc_normalizer, GeoPoint, dm2decimal, km_to_nm, km_to_rad, nm_to_rad, rad_to_km, rad_to_nm, NM, R */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"array_normalizer\", function() { return array_normalizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dm_normalizer\", function() { return dm_normalizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arinc_normalizer\", function() { return arinc_normalizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoPoint\", function() { return GeoPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dm2decimal\", function() { return dm2decimal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"km_to_nm\", function() { return km_to_nm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"km_to_rad\", function() { return km_to_rad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nm_to_rad\", function() { return nm_to_rad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rad_to_km\", function() { return rad_to_km; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rad_to_nm\", function() { return rad_to_nm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NM\", function() { return NM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R\", function() { return R; });\n/* harmony import */ var _geolite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geolite */ \"./src/modules/geolite.js\");\n\n\n\n// eath mean radius in meters\n// nm in meters\nconst R = 6371000.0\nconst NM = 1852.0\n\n// Converters\nconst rad_to_nm = (radians) => radians * R / NM;\nconst rad_to_km = (radians) => radians * R / 1000.0;\nconst nm_to_rad = (nm) => nm * NM / R;\nconst km_to_rad = (km) => km * 1000.0 / R;\nconst km_to_nm = (km) => km * 1000.0 / NM;\n\n/**\n * convert geo coordinates in degrees, minutes in signed fixed value\n *  N5500.0 => 55.00000000\n *  W02000.0 => -20.00000000\n * @param s String\n * @returns {number}\n */\nfunction dm2decimal(s) {\n    // convert geo coordinates in degrees, minutes in signed decimal value\n    // N5500.0 => Decimal('55.0')\n    // W02000.0 => Decimal('-20.0')\n    // :param s: str\n    const letter = s[0];\n    if ('NSEW'.indexOf(letter) < 0) throw new Error(\"invalid letter coordinates: \" + s);\n    const sign = (letter === 'N' || letter === 'E') ? 1 : -1;\n    const offset = (letter === 'N' || letter === 'S') ? 3 : 4;\n    const degrees = parseInt(s.slice(1, offset), 10);\n    const minutes = parseFloat(s.slice(offset));\n    return (sign * (degrees + minutes / 60))\n}\n\n// Normalizers\n/**\n *  Useful for testing (it is the default normalizer).\n *  It transforms an array into a LatLng\n * @param {number[]} array - [latitude, longitude]\n * @returns {LatLng}\n */\nfunction array_normalizer(array) {\n    if (array && array.length) {\n        return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](...array);\n    }\n    return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"]([0, 0])\n}\n\n/**\n * Normalize degrees minute value into LatLng\n * @param {string|string[]} mixedValue - 'N4038.4W07346.7' or ['N4038.4', 'W07346.7']\n * @returns {LatLng}\n */\nfunction dm_normalizer(mixedValue) {\n    let lat = 0,\n        lng = 0;\n    if (Array.isArray(mixedValue)) {\n        [lat, lng] = mixedValue;\n    } else {\n        lat = mixedValue.slice(0, 7);\n        lng = mixedValue.slice(7);\n    }\n    return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](dm2decimal(lat), dm2decimal(lng))\n}\n\n/**\n * Normalize ARINC point into LatLng\n * @param {string} label the arinc label\n * @returns {LatLng}\n */\nfunction arinc_normalizer(label) {\n    const signed = function (letter, lat, lng) {\n        switch (letter) {\n            case 'N': // NW + -\n                return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](lat, -lng);\n            case 'E': // NE + +\n                return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](lat, lng);\n            case 'S': // SE - +\n                return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](-lat, lng);\n            case 'W': // SW - -\n                return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](-lat, -lng);\n            default:\n                throw new Error('invalid letter');\n        }\n    };\n    let lat = 0,\n        lng = 0;\n    if ('NESW'.indexOf(label[0]) >= 0) {\n        // N5520  lon<100\n        lat = parseInt(label.slice(1,3), 10) + 0.5;\n        lng = parseInt(label.slice(3, 5), 10);\n        return signed(label[0], lat, lng);\n    } else if ('NESW'.indexOf(label[1]) >=0) {\n        // 5N520  lon>=100\n        lat = parseInt(label[0] + label[2], 10) + 0.5;\n        lng = parseInt(\"1\" + label.slice(3,5), 10);\n        return signed(label[1], lat, lng);\n    } else if ('NS'.indexOf(label[4]) >= 0) {\n        // 5530N020W => N5530.0W02000.0 => (55.5, -20)\n        // 5530N02000W => N5530.0W02000.0 => (55.5, -20)\n        lat = dm2decimal(label[4] + label.slice(0, 4) + \".0\");\n        lng = dm2decimal((label.slice(-1) + label.slice(5, -1) + \"00\").slice(0, 5) + \".0\");\n    } else {\n        // 55N020W => N5500.0W02000.0 => (55.0, -20)\n        lat = dm2decimal(label[2] + label.slice(0, 2) + \"00.0\");\n        lng = dm2decimal(label.slice(-1) + label.slice(3, -1) + \"00.0\");\n    }\n    return new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](lat, lng);\n}\n\n\n/** GeoPoint class is the base element to construct a Route */\nclass GeoPoint {\n\n    /**\n     * Create a GeoPoint.\n     * @param {GeoPoint|LatLng|*} mixedValue - any value type supported by the normalizer\n     * @param {string} [name=\"\"]\n     * @param {string} [description=\"\"]\n     * @param {?function} [normalizer=array_normalizer]\n     */\n    constructor(mixedValue, {name=\"\", description=\"\", normalizer=array_normalizer} = {}){\n        if (mixedValue instanceof GeoPoint) {\n            this.latlng = mixedValue.latlng;\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else if (mixedValue instanceof _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"]) {\n            this.latlng = mixedValue;\n        } else if (mixedValue\n            && Reflect.has(mixedValue, \"longitude\")\n            && Reflect.has(mixedValue, \"latitude\")) {\n            this.latlng = new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatLng\"](parseFloat(mixedValue.latitude), parseFloat(mixedValue.longitude));\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else {\n            this.latlng = normalizer ? normalizer(mixedValue) : mixedValue;\n        }\n        this.name = name.trim();\n        this.description = description;\n        this.latphi_cache = null;\n        this.dm_cache = null;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'GeoPoint';\n    }\n\n    get latitude() {\n        return this.latlng.latitude;\n    }\n    get longitude() {\n        return this.latlng.longitude;\n    }\n\n    /**\n     * Lazy conversion LatPhi\n     * @returns {LatPhi}\n     */\n    get latphi() {\n        if (this.latphi_cache === null) {\n            this.latphi_cache = this.latlng.asLatPhi;\n        }\n        return this.latphi_cache;\n    }\n\n    /**\n     * Lazy Degrees Minutes String representation\n     * @returns {null}\n     */\n    get dm() {\n        if (this.dm_cache === null) {\n            this.dm_cache = this.latlng.asDM;\n        }\n        return this.dm_cache;\n    }\n\n    /**\n     * Get the spherical distance beetween two GeoPoints\n     * @param {GeoPoint} geopoint1\n     * @param {GeoPoint} geopoint2\n     * @param {?function} converter - by default results in radians\n     * @returns {*}\n     */\n    static distance(geopoint1, geopoint2, converter=null) {\n        return geopoint1.distanceTo(geopoint2, converter)\n    }\n\n    /**\n     * Returns a pseudo center points from a list of GeoPoints\n     * @param {GeoPoint[]} geopoints\n     * @param {?Object} options\n     * @param {string} options.name\n     * @param {string} options.description\n     * @param {?function} options.normalizer\n     * @returns {GeoPoint}\n     */\n    static getCenter(geopoints, options){\n        let howMany = geopoints.length,\n            phi = 0,\n            rlat = 0,\n            x = 0,\n            y = 0,\n            z = 0;\n\n        for (let p of geopoints) {\n            rlat = p.latphi.rlat;\n            phi = p.latphi.phi;\n            let cosrlat = Math.cos(rlat);\n            x += cosrlat * Math.cos(phi);\n            y += cosrlat * Math.sin(phi);\n            z += Math.sin(rlat);\n        }\n        x /= howMany;\n        y /= howMany;\n        z /= howMany;\n        rlat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        phi = Math.atan2(y, x);\n        return new GeoPoint(new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatPhi\"](rlat, phi).asLatLng, options || {});\n    }\n\n    /**\n     * Get the spherical distance from another GeoPoint\n     * @param {GeoPoint} other Geopoint\n     * @param {?function} [converter=null] - by default distance in radians\n     * @returns {number} the distance in the unit set by the converter\n     */\n    distanceTo(other, converter=null) {\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        const sd = Math.acos(\n            Math.sin(rlat1) * Math.sin(rlat2)\n            + Math.cos(rlat1) * Math.cos(rlat2) * Math.cos(phi2 - phi1)\n        );\n        if (converter !== null) {\n            return converter(sd);\n        }\n        return sd;\n    }\n\n    /**\n     * computes intermediate point at fraction of other on great circle\n     * if distance=null, the required distance will be computed\n     * @param {GeoPoint} other GeoPoint\n     * @param {number} [fraction=0.5] - between 0 and 1\n     * @param {?number} [distance=null] - optional pre-computed distance in radians\n     * @returns {GeoPoint}\n     */\n    atFraction(other, fraction=0.5, distance=null) {\n        const d = (distance === null) ? this.distanceTo(other) : distance;\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        const a = Math.sin((1 - fraction) * d) / Math.sin(d);\n        const b = Math.sin(fraction * d) / Math.sin(d);\n        const x = a * Math.cos(rlat1) * Math.cos(phi1) + b * Math.cos(rlat2) * Math.cos(phi2);\n        const y = a * Math.cos(rlat1) * Math.sin(phi1) + b * Math.cos(rlat2) * Math.sin(phi2);\n        const z = a * Math.sin(rlat1) + b * Math.sin(rlat2);\n        const rlat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        const phi = Math.atan2(y, x);\n        return new GeoPoint(new _geolite__WEBPACK_IMPORTED_MODULE_0__[\"LatPhi\"](rlat, phi).asLatLng);\n    }\n\n    equals(other){\n        return (this.latitude.toFixed(6) === other.latitude.toFixed(6)\n            && this.longitude.toFixed(6) === other.longitude.toFixed(6))\n    }\n\n    toJSON(){\n        // TODO still useful or should return a geojson feature enclosing the point ?\n        return {\n            '__geopoint__': true,\n            'latitude': this.latitude.toFixed(6),\n            'longitude': this.longitude.toFixed(6),\n            'name': this.name,\n            'description': this.description\n        };\n    }\n}\n\n\n\n\n//# sourceURL=webpack://editolido/./src/modules/geopoint.js?");

/***/ }),

/***/ "./src/modules/kml.js":
/*!****************************!*\
  !*** ./src/modules/kml.js ***!
  \****************************/
/*! exports provided: KMLGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KMLGenerator\", function() { return KMLGenerator; });\n/* harmony import */ var _kml_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kml_constants */ \"./src/modules/kml_constants.js\");\n/* harmony import */ var _kml_templates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kml_templates */ \"./src/modules/kml_templates.js\");\n/* eslint-disable max-lines */\n\n\n\n/**\n * KMLFolder class\n * this a KML folder representation optimized for recreating live the KML:\n * @property {boolean} enabled - toggle the linestring visibility\n * @property {number} pin - change placemark icon style\n */\nconst pinProp = Symbol('pin private property');\n\nclass KMLFolder {\n\n    /**\n     * create a folder\n     * @param {string} name\n     * @param {Object} options - options is send to the kml renderer\n     * @param {number} [options.pinId] - the pinId used by this folder\n     * @param {boolean} [options.enabled=true] - show/hide this folder output's\n     */\n    constructor(name, options={}){\n        this.name = name;\n        this.options = options;\n        this.linestrings = []; // {String[]}\n        this.placemarks = []; // {Object[]}\n        this.lineStyle = {};\n        this[pinProp] = (options.pinId === undefined) ? _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PIN_NONE\"] : options.pinId;\n        this.enabled = (options.enabled === undefined) ? true : options.enabled;\n    }\n    get pin() {\n        return this[pinProp];\n    }\n\n    /**\n     * empty the folder data\n     */\n    empty(){\n        this.linestrings = [];\n        this.placemarks = [];\n    }\n\n    /**\n     * set a new default pin value for the folder\n     * @param {number} newValue - the new pin to use\n     */\n    set pin(newValue){\n        const oldStyle = _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PINS\"][this[pinProp]];\n        this[pinProp] = newValue;\n        const newStyle = _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PINS\"][newValue];\n        //replace all styles using oldStyle with newStyle\n        this.placemarks = this.placemarks.map(o => {\n            if (o.style === oldStyle) {\n                o.style = newStyle;\n            }\n            return o;\n        });\n    }\n}\n\n/**\n * KMLGenerator class\n * it's a virtual representation of kml elements\n *\n * The python version filter elements on input.\n * To allow reactive rendering, here we filter elements on output\n *\n * Change\n */\nclass KMLGenerator {\n\n    /**\n     * Create a KML generator\n     * @param {Object} [renderers]\n     * @param {function} [renderers.template=template] - global template renderer\n     * @param {function} [renderers.pointTemplate=pointTemplate] - placemark rendere\n     * @param {function} [renderers.lineTemplate=lineTemplate] - linestring renderer\n     * @param {function} [renderers.folderTemplate=folderTemplate] - folder renderer\n     * @param {function} [renderers.styleTemplate=styleTemplate] - style renderer for linestring\n     * @param {function} [renderers.iconTemplate=iconTemplate] - style renderer for placemarks\n     * @param {function} [renderers.segmentTemplate=segmentTemplate] - linestring segments renderer\n     * @param {function} [renderers.icons=GOOGLEICONS] - icons (pins) to use\n     */\n    constructor(renderers={}) {\n        this.folders = new Map();\n        this.template = renderers.template || _kml_templates__WEBPACK_IMPORTED_MODULE_1__[\"template\"];\n        this.pointTemplate = renderers.pointTemplate || _kml_templates__WEBPACK_IMPORTED_MODULE_1__[\"pointTemplate\"];\n        this.lineTemplate = renderers.lineTemplate || _kml_templates__WEBPACK_IMPORTED_MODULE_1__[\"lineTemplate\"];\n        this.folderTemplate = renderers.folderTemplate || _kml_templates__WEBPACK_IMPORTED_MODULE_1__[\"folderTemplate\"];\n        this.styleTemplate = renderers.styleTemplate || _kml_templates__WEBPACK_IMPORTED_MODULE_1__[\"styleTemplate\"];\n        this.iconTemplate = renderers.iconTemplate || _kml_templates__WEBPACK_IMPORTED_MODULE_1__[\"iconTemplate\"];\n        this.segmentTemplate = renderers.segmentTemplate || _kml_templates__WEBPACK_IMPORTED_MODULE_1__[\"segmentTemplate\"];\n        this.icons = renderers.icons || _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"GOOGLEICONS\"];\n    }\n\n    /**\n     * replace common invalid xml characters from a string\n     * @param {string} text\n     * @returns {string}\n     */\n    static escape (text) {\n        return text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace(\"\\\"\", \"&quot;\");\n    }\n\n    /**\n     * determine style using pin[options.style]/options.style/#folderName\n     * @param {string} folderName\n     * @param {?Object} options\n     * @param {string|number} [options.style]\n     * @param {boolean} [folderPinInherit=false] - consider folder pin if defined\n     * @returns {Object} options - new options to use\n     */\n    computeOptions (folderName, options={}, folderPinInherit=false) {\n        options = {...options}; // work on a copy\n        if (folderPinInherit && options.style === undefined) {\n            let {style = this.folders.get(folderName).pin} = options;\n            options.style = style;\n        }\n        if (options.style === undefined) {\n            options.style = '#' + folderName;\n        } else if (!isNaN(options.style)) {\n            options.style = _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PINS\"][options.style];\n        }\n        return options; // return a copy of options with a style override\n    }\n\n    /**\n     * add a folder in our virtual kml\n     * @param {string} name\n     * @param {Object} options - options passed to the template\n     * @param {number} [options.pinId=0] - the pin identifier\n     */\n    addFolder (name, options={}) {\n        // create a folder entry and add necessary styles\n        let folder = new KMLFolder(name, options);\n        this.folders.set(name, folder);\n        let value = {'id': name, 'color': name + '_color'};\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * add multiple folders in our virtual kml\n     * @param {...{string|Object}} items - ...{name, [pin=0], ...}\n     * @param {string} items.name - folder name\n     * @param {number} items.pin - folder pinId\n     */\n    addFolders (...items) {\n        for (let value of items) {\n            if (typeof(value) === 'string' || value instanceof String){\n                this.addFolder(value);\n            } else {\n                let clone = {...value}; // get a copy\n                Reflect.deleteProperty(clone, \"name\");\n                this.addFolder(value.name, clone);\n            }\n        }\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addLine(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        let value = {\n            'name': options.name || route.name,\n            'style': options.style,\n            'description': options.description || route.description\n        };\n        this.folders.get(folderName).linestrings.push(\n            this.renderLine(route.points, {...value, ...options})); //options override value\n\n    }\n\n    /**\n     * add route as points in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     * @param {Array} [options.excluded=[]] - a list of points to omit\n     */\n    addPoints(folderName, route, options={}) {\n        const excluded = options.excluded || [];\n        options = this.computeOptions(folderName, options, true);\n        for (let point of route.points) {\n            if (excluded.indexOf(point) >= 0) {\n                options.style = _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PIN_NONE\"];\n            }\n            this.addPoint(folderName, point, options);\n        }\n    }\n\n    /**\n     * add a point to a folder\n     * @param {string} folderName\n     * @param {GeoPoint} point\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value (with folder pin's inheritance)\n     */\n    addPoint ( folderName, point, options={}) {\n        options = this.computeOptions(folderName, options, true);\n        // as each point may have a dynamic style option,\n        // we delegate the rendering to the folder by storing objects instead of string\n        this.folders.get(folderName)\n            .placemarks.push({point, ...options});\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addSegments(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        for (let [p1, p2] of route.segments){\n            const label = route.name || folderName;\n            const value = {\n                'name': `${label}: ${p1.name || p1.dm}->${p2.name || p2.dm}`,\n            }\n            this.folders.get(folderName).linestrings.push(\n                this.renderLine([p1, p2], {...value, ...options}, true));// options override value\n        }\n    }\n\n    /**\n     * render the whole KML\n     * @param {Route} route\n     * @param {?Object} [options={}] - options is passed to the kml templates\n     * @returns {string}\n     */\n    render(options={}){\n        let styles = '';\n        _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PINS\"].forEach((value, index) => {\n            if (index !== 0) {\n                value = {'id': _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PINS\"][index].slice(1), 'href': this.icons[index]};\n                styles += this.iconTemplate({...value, ...options});\n            }\n        });\n\n        for (let [,folder] of this.folders){\n            if (folder.enabled) {\n                styles += this.styleTemplate(folder.lineStyle)\n            }\n        }\n        return this.template({...options, \"styles\": styles, \"folders\": this.renderFolders()});\n    }\n\n    /**\n     * render a single folder\n     * @param {string|KMLFolder} folder - accepts a name or a Map iteration element\n     * @returns {string}\n     */\n    renderFolder (folder, renderer=this.folderTemplate){\n        if (typeof(folder) === 'string' || folder instanceof String) {\n            folder = this.folders.get(folder);\n        }\n        if (!folder.enabled) return '';\n        // linestrings never change the folder is simply enabled or disabled\n        // placemarks are dynamic due to the excluded parameter\n        let placemarks = [];\n        if (folder.pin === _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PIN_NONE\"] || folder.pin === undefined){\n            placemarks = folder.placemarks\n                .filter(o => o.style !== _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PINS\"][_kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PIN_NONE\"]] && o.style !== undefined);\n        } else {\n            placemarks = folder.placemarks\n                .filter(o => o.style !== _kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PINS\"][_kml_constants__WEBPACK_IMPORTED_MODULE_0__[\"PIN_NONE\"]]);\n        }\n        let value = {\n            \"name\": folder.name,\n            \"content\": folder.linestrings.concat(\n                placemarks.map(o => this.pointTemplate(o, o.style)))\n                .join('\\n')\n        };\n        return renderer({...value, ...folder.options});\n    }\n\n    /**\n     * render all folders\n     * @returns {string}\n     */\n    renderFolders () {\n        let output = [];\n        for (let [, folder] of this.folders) {\n            output.push(this.renderFolder(folder));\n        }\n        return output.join('\\n');\n    }\n\n    /**\n     * line/segment renderer\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}] - options is passed to the kml template\n     * @param {boolean} isSegment - determine the template: segment or line\n     * @returns {string}\n     */\n    renderLine (points, options={}, isSegment=false){\n        const tpl = (p) => `${p.longitude.toFixed(6)},${p.latitude.toFixed(6)}`;\n        const coordinates = points.map(p => tpl(p)).join(' ');\n        const value = {...options, coordinates};\n        return isSegment ? this.segmentTemplate(value) : this.lineTemplate(value);\n    }\n\n    /**\n     * Change the Style of a folder, thus changing color\n     * @param {string} name\n     * @param {string} color\n     * @param {Object} [options] - additional options passed to the template\n     */\n    changeFolderColor(name, color, options={}){\n        const value = {'id': name, 'color': color};\n        const folder = this.folders.get(name);\n        folder.lineStyle = this.styleTemplate({...value, ...options});\n    }\n\n    /**\n     * Change folder pin shortcut\n     * @param {string} name\n     * @param {number} pin - the pin id\n     */\n    changeFolderPin(name, pin){\n        this.folders.get(name).pin = pin\n    }\n\n    /**\n     * Change folder state shortcut\n     * @param {string} name\n     * @param {boolean} enabled - enable or disable folder\n     */\n    changeFolderState(name, enabled){\n        this.folders.get(name).enabled = enabled;\n    }\n\n    /**\n     * reset KML Generator\n     */\n    reset(){\n        for (let [, folder] of this.folders){\n            folder.empty();\n        }\n    }\n\n}\n\n\n\n\n//# sourceURL=webpack://editolido/./src/modules/kml.js?");

/***/ }),

/***/ "./src/modules/kml_constants.js":
/*!**************************************!*\
  !*** ./src/modules/kml_constants.js ***!
  \**************************************/
/*! exports provided: PIN_NONE, PIN_BLUE, PIN_YELLOW, PIN_BROWN, PIN_ORANGE, PIN_PINK, PIN_RED, PIN_GREEN, PIN_PURPLE, NAT_POSITION_ENTRY, NAT_POSITION_EXIT, PINS, GOOGLEICONS, AVENZAICONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_NONE\", function() { return PIN_NONE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_BLUE\", function() { return PIN_BLUE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_YELLOW\", function() { return PIN_YELLOW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_BROWN\", function() { return PIN_BROWN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_ORANGE\", function() { return PIN_ORANGE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_PINK\", function() { return PIN_PINK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_RED\", function() { return PIN_RED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_GREEN\", function() { return PIN_GREEN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_PURPLE\", function() { return PIN_PURPLE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAT_POSITION_ENTRY\", function() { return NAT_POSITION_ENTRY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAT_POSITION_EXIT\", function() { return NAT_POSITION_EXIT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PINS\", function() { return PINS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GOOGLEICONS\", function() { return GOOGLEICONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AVENZAICONS\", function() { return AVENZAICONS; });\nconst PIN_NONE = 0\nconst PIN_BLUE = 1\nconst PIN_YELLOW = 2\nconst PIN_BROWN = 3 // not available in Avenza\nconst PIN_ORANGE = 4\nconst PIN_PINK = 5 // not available in Avenza\nconst PIN_RED = 6\nconst PIN_GREEN = 7\nconst PIN_PURPLE = 8\n\nconst NAT_POSITION_ENTRY = 0\nconst NAT_POSITION_EXIT = 1\n\nconst PINS = [\n    '#placemark-none', '#placemark-blue', '#placemark-yellow',\n    '#placemark-brown', '#placemark-orange', '#placemark-pink',\n    '#placemark-red', '#placemark-green', '#placemark-purple'];\n\nconst GOOGLEICONS = [\n    'FFFFFF', '6699FF', 'FFFF00',\n    'CC9966', 'FF9922', 'DD5599',\n    'FF0000', '22DD44', 'BB11EE',\n].map(c => `http://chart.googleapis.com/chart?chst=d_map_pin_letter&chld=|${c}`);\n\n/**\n * Avenza is missing color 3 and 5: brown and pink displayed as red\n * @type {string[]}\n */\nconst AVENZAICONS = [\n    'null', 'blue', 'yellow',\n    'red', 'orange', 'red',\n    'red', 'green', 'purple',\n].map(c => `'http://download.avenza.com/images/pdfmaps_icons/pin-${c}-inground.png'`);\n\n\n//# sourceURL=webpack://editolido/./src/modules/kml_constants.js?");

/***/ }),

/***/ "./src/modules/kml_templates.js":
/*!**************************************!*\
  !*** ./src/modules/kml_templates.js ***!
  \**************************************/
/*! exports provided: pointTemplate, lineTemplate, segmentTemplate, folderTemplate, template, avenzaTemplate, styleTemplate, avenzaStyleTemplate, iconTemplate, avenzaIconTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointTemplate\", function() { return pointTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineTemplate\", function() { return lineTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"segmentTemplate\", function() { return segmentTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"folderTemplate\", function() { return folderTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"template\", function() { return template; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"avenzaTemplate\", function() { return avenzaTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"styleTemplate\", function() { return styleTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"avenzaStyleTemplate\", function() { return avenzaStyleTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"iconTemplate\", function() { return iconTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"avenzaIconTemplate\", function() { return avenzaIconTemplate; });\n/**\n * Templates are use dynamically, that's why we use functions.\n */\n\n\n/**\n * Placemark renderer\n * @param {LatLng|GeoPoint} point\n * @param {string} name\n * @param {string} style - exemple '#placemark-red'\n * @param {string} description\n * @returns {string}\n */\nconst pointTemplate = ({point, style}) => `\n     <Placemark>\n      <name><![CDATA[${point.name || point.dm}]]></name>\n      <styleUrl>${style}</styleUrl>\n      <description><![CDATA[${point.description || ''}]]></description>\n      <Point>\n        <coordinates>${point.longitude.toFixed(6)},${point.latitude.toFixed(6)}</coordinates>\n      </Point>\n    </Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72 2.21,47.90\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nconst lineTemplate = ({coordinates, name, style, description}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <description><![CDATA[${description}]]></description>\n  <LineString>\n    <tessellate>1</tessellate>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nconst segmentTemplate = ({coordinates, name, style}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <LineString>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Folder renderer\n * @param {string} name\n * @param {string} content\n * @param {string|number} [open=1] - not recognized by mapsme/avenza\n * @returns {string}\n */\nconst folderTemplate = ({name, content, open=1}) => `\n<Folder>\n    <name>${name}</name>\n    <open>${open}</open>\n    ${content}\n</Folder>\n`;\n\n\n/**\n * Global KML renderer\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nconst template = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        ${folders}\n  </Document>\n</kml>\n`;\n\n\n/**\n * Global KML renderer for Avenza (uses an additional root folder)\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nconst avenzaTemplate = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        <Folder><name><![CDATA[${name}]]></name>\n        ${folders}\n        </Folder>\n  </Document>\n</kml>\n`;\n\n\n/**\n * LineStyle Style renderer\n * @param {string} id - the style id, exemple: 'my-folder-name'\n * @param {string} color - kml color to use, inversed from web color: 641400FF for #FF0014 with 100% opacity\n * @param {number|string} [width=6] - the width of the line, set to 2 for Avenza\n * @returns {string}\n */\nconst styleTemplate = ({id, color, width=6}) => `\n    <Style id=\"${id}\">\n        <LineStyle>\n            <width>${width}</width>\n            <color>${color}</color>\n        </LineStyle>\n    </Style>\n`;\n\nconst avenzaStyleTemplate = ({id, color, width=2}) => styleTemplate({id, color, width});\n\n/**\n * IconsStyle Style renderer\n * @param {string} id - the style id, exemple: \"placemark-red\"\n * @param {string} href - url of the icons (not used by mapsme)\n * @param {string} [x=\"0.5\"] - hotspot zone x\n * @param {string} [y=\"0.0\"] - hotspot zone y, set to \"0.5\" for Avenza\n * @returns {string}\n */\nconst iconTemplate = ({id, href, x=\"0.5\", y=\"0.0\"}) => `\n    <Style id=\"${id}\">\n        <IconStyle>\n            <Icon>\n                <href><![CDATA[${href}]]></href>\n            </Icon>\n            <hotSpot x=\"${x}\"  y=\"${y}\" xunits=\"fraction\" yunits=\"fraction\"/>\n        </IconStyle>\n    </Style>\n`;\n\nconst avenzaIconTemplate = ({id, href, x=\"0.5\", y=\"0.5\"}) => iconTemplate({id, href, x, y});\n\n\n//# sourceURL=webpack://editolido/./src/modules/kml_templates.js?");

/***/ }),

/***/ "./src/modules/route.js":
/*!******************************!*\
  !*** ./src/modules/route.js ***!
  \******************************/
/*! exports provided: Route, Track */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Route\", function() { return Route; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Track\", function() { return Track; });\n/* harmony import */ var _geopoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geopoint */ \"./src/modules/geopoint.js\");\n\n\n\n/** Class representing a route. */\nclass Route {\n\n    /**\n     * Create a route.\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     */\n    constructor(points, {name=\"\", description=\"\"} = {}) {\n        this.points = points || [];\n        this.name = name;\n        this.description = description;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Route';\n    }\n\n    /**\n     * Route iterator - iterates over the route's points\n     * @returns {GeoPoint|*}\n     */\n    get [Symbol.iterator] () {\n        return this.points[Symbol.iterator];\n    }\n    // implementing like this causes a ReferenceError: regeneratorRuntime is not defined\n    // *[Symbol.iterator]() {\n    //     yield* this.points;\n    // }\n\n    /**\n     * check if two routes contains the same points\n     * @param route2\n     * @returns {boolean}\n     */\n    equals(route2) {\n        if (this.points.length !== route2.points.length) return false;\n        const zip = (a, b) => a.map((e, i) => [e, b[i]]);\n        for (let [p1, p2] of zip(this.points, route2.points)) {\n            if (! p1.equals(p2)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * if route points are [a, b, c], this returns [[a, b], [b, c]]\n     * @returns {Array}\n     */\n    get segments() {\n        let segments = [];\n        if (this.points.length > 0){\n            this.points.reduce((prev, current) => {\n                segments.push([prev, current]);\n                return current;\n            });\n        }\n        return segments;\n    }\n\n    /**\n     * Returns the distance of the route, unit is set by the converter.\n     * @param {?function} converter - if null returns the distance in radians\n     * @returns {number}\n     */\n    distance(converter=_geopoint__WEBPACK_IMPORTED_MODULE_0__[\"rad_to_nm\"]) {\n        const distance = this.segments\n            .map(([p1, p2]) => p1.distanceTo(p2))\n            .reduce((accumulator, current) => accumulator + current, 0);\n        if (converter === null) {\n            return distance;\n        }\n        return converter(distance);\n    }\n\n    /**\n     * Split a route in smaller segments.\n     * The new Route might be different from the original one as original\n     * start and end of inner segments are not preserved by default.\n     *\n     * @param {number} maxLength - length of the segment, by default in NM\n     * @param {?Object} options - additional options are the Route options\n     * @param {?function} options.converter - must transform maxLength in radians\n     * @param {boolean} options.preserve - if false, split at maxLength, do not keep intermediary points\n     * @param {string} options.name - generated route name\n     * @param {string} options.description - generated route description\n     * @returns {Route}\n     */\n    split(maxLength, options){\n        let {converter=_geopoint__WEBPACK_IMPORTED_MODULE_0__[\"nm_to_rad\"], preserve=false} = options || {};\n        let points = [];\n        let remaining = 0;\n        let first = true;\n        let maxRadians = (converter) ? converter(maxLength) : maxLength\n        let geopoint1 = null,\n            geopoint2 = null;\n        for ([geopoint1, geopoint2] of this.segments) {\n            if (first) {\n                first = false;\n                points.push(geopoint1); // first point\n            }\n            let segmentLength = geopoint1.distanceTo(geopoint2);\n            let d = remaining\n            while (d <= segmentLength - maxRadians) {\n                d += maxRadians;\n                points.push(geopoint1.atFraction(geopoint2, d / segmentLength, segmentLength));\n            }\n            remaining = parseFloat((d - segmentLength).toFixed(10)); // <=> python round(value, 10)\n            if (preserve && remaining) {\n                points.push(geopoint2);\n                remaining = 0;\n            }\n        }\n        if (remaining) {\n            points.push(geopoint2); // last if not emitted\n        }\n        return new Route(points, options);\n    }\n}\n\n/**\n * a Track is a Route with additional properties and methods\n */\nclass Track extends Route {\n\n    /**\n     * Track constructor\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     * @param {boolean} [options.isMine=false] - true when my route uses this track\n     * @param {boolean} [options.isComplete=true] - true when there is no missing points in the track\n     */\n    constructor(points, options) {\n        let {isMine=false, isComplete=true} = options || {};\n        super(points, options);\n        this.isMine = isMine;\n        this.isComplete = isComplete;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Track';\n    }\n}\n\n\n\n\n//# sourceURL=webpack://editolido/./src/modules/route.js?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.js */\"./src/index.js\");\n\n\n//# sourceURL=webpack://editolido/multi_./src/index.js?");

/***/ })

/******/ });
});